// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

#include "ap_def.h"
#include "web/mongoose/mongoose_glue.h"
#include <zephyr/net/net_mgmt.h>
#include <zephyr/net/net_if.h>  // to get the IP address


static K_THREAD_STACK_DEFINE(thread_stack, _HW_DEF_RTOS_THREAD_MEM_WEB);
static struct k_thread thread_data;

static void web_set_leds(struct leds *data);


// Zephyr: Define a semaphore and network management callback to be able to wait
// until our IP address is ready. The main function will start and block on this
// semaphore until this event handler releases it when the network is ready
K_SEM_DEFINE(run, 0, 1);

// https://docs.zephyrproject.org/latest/releases/migration-guide-4.2.html#networking
static void zeh(struct net_mgmt_event_callback *cb,
#if ZEPHYR_VERSION_CODE < 0x40200
                uint32_t mgmt_event,
#else
                uint64_t mgmt_event,
#endif
                struct net_if *iface) {
  if (mgmt_event == NET_EVENT_L4_CONNECTED) k_sem_give(&run);
}

// Zephyr: Extract IP address when using DHCP
static void print_ipv4_address(void)
{
  struct net_if            *iface  = net_if_get_default();
  struct net_if_config     *cfg    = &iface->config;
  const struct net_if_addr *ifaddr = (const struct net_if_addr *)&cfg->ip.ipv4->unicast[0];
  MG_INFO(("IP: %M", mg_print_ip, &ifaddr->address.in_addr));
}

int web_main(void)
{
  struct net_mgmt_event_callback ncb;
  // Zephyr: Register the network management callback and block on the semaphore
  net_mgmt_init_event_callback(&ncb, zeh, NET_EVENT_L4_CONNECTED);
  net_mgmt_add_event_callback(&ncb);
  k_sem_take(&run, K_FOREVER);

  print_ipv4_address();


  mongoose_set_http_handlers("leds", glue_get_leds, web_set_leds);

  // This function blocks forever. Call it in a
  // separate RTOS task. Give that task 8k stack space.
  mongoose_init();
  for (;;)
  {
    mongoose_poll();
  }

  return 0;
}

void web_set_leds(struct leds *data)
{  
  glue_set_leds(data);

  data->led1 ? ledOn(_DEF_LED1):ledOff(_DEF_LED1);
  data->led2 ? ledOn(_DEF_LED2):ledOff(_DEF_LED2);
  data->led3 ? ledOn(_DEF_LED3):ledOff(_DEF_LED3);
}

void webThread(void const *arg)
{
  bool init_ret = true;


  moduleIsReady();

  logPrintf("[%s] Thread Started : WEB\n", init_ret ? "OK":"E_" );

  web_main();
}

bool webInit(void)
{
  bool ret;

  k_tid_t tid = k_thread_create(&thread_data, thread_stack,
                                  K_THREAD_STACK_SIZEOF(thread_stack),
                                  (k_thread_entry_t)webThread,
                                  NULL, NULL, NULL,
                                  _HW_DEF_RTOS_THREAD_PRI_WEB, 0, K_NO_WAIT);

  ret = tid != NULL ? true:false;                                  
  logPrintf("[%s] webInit()\n", ret ? "OK":"E_");

  return ret;
}

MODULE_DEF(web) 
{
  .name = "web",
  .priority = MODULE_PRI_LOW,
  .init = webInit
};